import { load } from 'cheerio';
import fs from 'fs';
import { Bookmark, Bookmarks, APIBook, Config } from '../types/bookmark_types.ts';
import { sortByKey, readConfig, puppeteerBrowser, sleep } from './misc.ts';
// import { spawn } from 'npm:child_process';

/**
 * Extract a list of bookmarks from an HTML string.
 *
 * This function is used to extract bookmarks from a bookmarks.html file
 * generated by Firefox.
 *
 * If the `duplicate` parameter is set to `true`, then the function will
 * return the list of bookmarks without removing duplicates.
 *
 * @param {string} html The HTML string to extract the bookmarks from.
 * @param {boolean} [duplicate=false] Whether or not to remove duplicate bookmarks.
 * @return {Bookmark[]} The list of extracted bookmarks.
 */
export function extractBookmarks(html: string, duplicate: boolean = false): Bookmark[] {
  const $ = load(html);
  const anchorTags = $('DL DT A');

  const bookmarks: Bookmark[] = [];
  anchorTags.get().forEach(anchorTag => {
    const href = anchorTag.attribs['href'];
    const name = (anchorTag.children[0] as unknown as Text).data;
    if (href && name) {
      bookmarks.push({ href, name });
    }
  });

  const sortedBookmarks = sortByKey(bookmarks, 'href').sort((a, b) => a.name.localeCompare(b.name));

  return duplicate ? sortedBookmarks : [...new Map(sortedBookmarks.map(v => [v.href, v])).values()];
}

/**
 * Sort bookmarks by website.
 *
 * This function takes a list of bookmarks and groups them by website.
 * The function also chunks the bookmarks by folder size and excludes websites
 * specified in the config file.
 *
 * @param {Bookmark[]} bookmarks The list of bookmarks to sort.
 * @return {Bookmarks[]} The sorted list of bookmarks.
 */
export function sortBookmarks(bookmarks: Bookmark[], testConfig?: Config): Bookmarks[] {
  const config = testConfig ? testConfig : readConfig();

  const websites: string[] = [];
  // Extract website name
  bookmarks.forEach(bookmark => {
    const website = getWebsite(bookmark.href);
    if (website && !websites.includes(website)) {
      websites.push(website);
    }
  });

  const sortedResult: Bookmarks[] = [];
  const sortedNotFound: Bookmark[] = [];

  websites.forEach(website => {
    const websiteBookmarks: Bookmark[] = [];
    const websiteFolder: Bookmarks = {
      website,
      children: [],
    };

    // Find and list website
    bookmarks.forEach(bookmark => {
      if (getWebsite(bookmark.href) === website) {
        websiteBookmarks.push(bookmark);
      }
    });

    if (websiteBookmarks.length >= Number(config.website!.folderExcludeSize)) {
      if (config.exclude!.website.includes(website)) {
        sortedNotFound.push(...websiteBookmarks);
      } else {
        const chunkSize = Number(config.website!.folderSize);
        if (chunkSize > 0) {
          for (let i = 0; i < websiteBookmarks.length; i += chunkSize) {
            const chunk = websiteBookmarks.slice(i, i + chunkSize);
            websiteFolder.children.push({
              website: `${website} ${i / chunkSize}`,
              children: chunk,
            });
          }
          sortedResult.push(websiteFolder);
        } else {
          sortedResult.push({ website, children: websiteBookmarks });
        }
      }
    } else {
      sortedNotFound.push(...websiteBookmarks);
    }
  });

  sortedResult.push({ website: 'none', children: sortedNotFound });
  return sortedResult;
}

/**
 * Extract the website name from a URL.
 *
 * @param {string} url - The URL to extract the website name from.
 * @returns {string | undefined} The website name, or undefined if the URL does not end with a top-level domain.
 */
export function getWebsite(url: string): string | undefined {
  try {
    const parsedUrl = new URL(url.startsWith('http://') || url.startsWith('https://') ? url : `http://${url}`);
    const domainParts = parsedUrl.hostname.split('.');

    // If the hostname has more than 2 parts, remove the subdomain
    return domainParts.length > 1 ? domainParts.slice(-2, -1)[0] : parsedUrl.hostname;
  } catch {
    return undefined;
  }
}

/**
 * Generate a Netscape Bookmark file from a nested list of bookmarks.
 *
 * This function takes a nested list of bookmarks and generates a Netscape Bookmark file from it.
 * The function will recursively traverse the nested list and generate the bookmark file.
 *
 * @param {Bookmarks[]} bookmarks The nested list of bookmarks.
 * @return {string} The generated Netscape Bookmark file as a string.
 */
export function generateBookmark(bookmarks: Bookmarks[]): string {
  const payload = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
<!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DT><H3>Collection</H3>
`;

  let result = '';

  function writeBookmarks(bookmarks: Bookmarks[] | Bookmark[], level: number) {
    const indent = '    '.repeat(level);

    result += `${indent}<DL><p>\n`;

    for (const bookmark of bookmarks) {
      if ('website' in bookmark) {
        result += `${indent}<DT><H3>${bookmark.website}</H3>\n`;
        writeBookmarks(bookmark.children as Bookmark[], level + 1);
      } else {
        result += `${indent}<DT><A HREF="${bookmark.href}">${bookmark.name}</A>\n`;
      }
    }

    result += `${indent}</DL><p>\n`;
  }

  writeBookmarks(bookmarks, 0);

  return payload + result;
}

export async function NHSorter(data: Bookmarks[]): Promise<Bookmarks[]> {
  const config = readConfig();
  const pageMin = 13;
  const codes: string[] = [];
  data.forEach(bookmark => {
    if (bookmark.website === 'nhentai') {
      codes.push(
        ...bookmark.children.flatMap(child => {
          const match = (child as Bookmark).href.match(/\/(\d{4,})(?=\/|$)/);
          return match ? [match[1]] : [];
        })
      );
    }
  });
  let jsonData: APIBook[] = [];

  const filteredData = data.filter(bookmark => bookmark.website !== 'nhentai');
  await sleep(2000);
  await puppeteerBrowser({ url: 'https://nhentai.net' }, async page => {
    await sleep(5000);
    await page.reload();
  });
  await sleep(10000);
  await puppeteerBrowser({ url: 'https://nhentai.net' }, async page => {
    await sleep(30000);

    const tagList = [...(config.website?.nh_tags as string[]), `pagelessthan${pageMin}`, 'noTags'];
    const placeholders: Bookmarks[] = tagList.map(tag => ({ website: tag, children: [] }));

    if (fs.existsSync('data_NH.json')) {
      jsonData = JSON.parse(fs.readFileSync('data_NH.json', 'utf8'));
    }
    let brokenCount = 0;
    for (const code of codes) {
      try {
        if (!jsonData.find(book => book.id === code)) {
          const url = `https://nhentai.net/api/gallery/${code}`;
          await page.goto(url);
          const json = await page.evaluate(() => JSON.parse(document!.querySelector('body')!.innerText));
          jsonData.push(json);
        }
        const book = jsonData.find(book => book.id === code)!;
        const matchedTags = book.tags.filter(tag => tagList.includes(tag.name));
        const firstMatchedTag = matchedTags.find(tag => tagList.includes(tag.name));

        for (const bookmark of data) {
          if (bookmark.website === 'nhentai') {
            for (const child of bookmark.children) {
              for (const grandchild of (child as { website: string; children: Bookmark[] }).children) {
                if (grandchild.href === `https://nhentai.net/g/${code}/`) {
                  if ((book.num_pages as number) <= pageMin) {
                    placeholders[placeholders.length - 2].children.push(grandchild);
                  } else if (firstMatchedTag) {
                    const objIndex = tagList.findIndex(obj => obj === firstMatchedTag.name);
                    placeholders[objIndex].children.push(grandchild);
                  } else {
                    placeholders[placeholders.length - 1].children.push(grandchild);
                  }
                }
              }
            }
          }
        }
      } catch (err) {
        brokenCount++;
      }
    }
    console.log(`Broken Count: ${brokenCount}`);
    filteredData.unshift({ website: 'nhentai', children: placeholders });
  });

  fs.writeFileSync('./data_NH.json', JSON.stringify(jsonData));
  return filteredData;
}

// Todo
export async function JVGRSorter(data: Bookmarks[]) {
  const config = readConfig();
  const urls: string[] = [];
  data.forEach(i => {
    if (i.website == 'jav') {
      i.children.forEach(j => {
        (j as { website: string; children: Bookmark[] }).children.forEach(k => {
          urls.push(k.href);
        });
      });
    }
  });
  // console.log(urls);
  await puppeteerBrowser({ url: '' }, async page => {});
}
